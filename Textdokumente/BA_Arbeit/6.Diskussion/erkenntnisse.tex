% Allgemeines:

% Das ist alles ein Plot eines DeepCascade Networks, welches vorgestellt wird:
Es kommt relativ schnell zu Overfitting auf dem Sourcedatensatz. % Veränderung, wann TF gemacht wird.
% ConvMaxPool = Deep Cascade

Bei der Stelle des TFs bricht die Performanz des Netzes ein. Diese erholt sich wieder etwas, aber nicht auf dasselbe Level wie zuvor. 
% Jeder Plot mit TF 
% Deep Cascade, aber auch OneLayer; Direct Cascade Classification nicht, da keine Stabilisierung

% Bei Deep Cascade benötigt es weniger Epochen nach TF bis sich die Performanz der Netze stabilisiert. 
% Irgendein Deep Cascade Plot -> Das war falsch!

Die normalen Netzwerke sind in der hier vorliegenden Implementierung mit kleinen Datensätzen schneller als die Direct Cascade und diese 
wiederum schneller als die Deep Cascade Netze. 
Sie sind in der Performanz aber unterschiedlich gut. \newline
% Die Direct Cascade Netze sind erheblich schneller als die Deep Cascade und diese sind wiederum schneller als die normalen Netze. 
% Zeitnahme zwischen Direct und Deep
% Direct 1DConv, Deep Cascade TF und Full(DCAS)
% Zeitnahme zwischen OneLayer vs. RegressionTwo

% Inverses Deep Cascade ist völliger Blödsinn. \newline
% Höchstens als Bemerkung

% Klassifikation: 

Bei der Klassifikation ist der endgültige Accuracy-Wert hauptsächlich von der Datenmenge des Targetdatensatzes abhängig. 
Je weniger Daten, desto schlechter ist der Wert. % Veränderung wieviele Targetdaten genutzt werden
% OneDConv, ConvMaxPool

Klassifikation läuft so schlecht, dass man es nicht tun sollte, da es nichts bringt, wenn diese nur zu 20\% richtig liegt. 
% Jedes Klassifikationsnetz mit TF, vor allem bei Direct Cascade
% ClassOneDense

Bei TF ist die Performanz des Netzes etwas schlechter als ohne. % Vergleich zwischen TF und ohne bei Deep Cascade beides und bei Direct Cascade Klassifikation
% Deep Cascade TF vs. Deep Cascade
Ein Cascade Netzwerk ist ebenfalls schlechter als ein Komplettes. % Vergleich zwischen Cascade und Gesamtnetze
% Deep Cascade vs. Ohne


Die Erstellung bei mehrdimensionalen Augmented Vectors kann zur Arbeitsspeicherplatzproblemen führen. % 2D-Class augmentation vector update
% 2DConv

Eindimensionale Klassifikation ist minimal schlechter als zweidimensionale. Dies ist aber so gering, dass es Vernachlässigbar ist. \newline
% Vergleich zwischen 1D und 2D.
% 1DConv vs 2DConv

% Regression:

Die Regression ist mit TF bei wenigen Daten besser als, wenn sie auf den Targetdatensatz von Scratch lernt. 
Aber nur, wenn es sich um Direct Cascade handelt. 
% Vergleich zwischen TF und Scratch Regression
% OneLayer TF/Scratch (Very Less Data)


In der Regression ist der Abfall der Performanz bei weitem weniger groß. % Regressionsnetz mit und ohne TF
% OneLayer TF/Scratch (Full Data)

Die simplen hier aufgeführten Early-Stopping Metriken verschlechtern das Ergebnis, da diese in lokalen Minima stecken bleiben. 
